/-

Formalization of basic point-set topology.

- Mathlib docs: https://leanprover-community.github.io/mathlib4_docs/
- Loogle: https://loogle.lean-lang.org/
- editor shortcuts:
  - mathcal characters e.g. ‚Ñ¨, ùí©, ùí™, ùíØ, ùí∞ are \McB, \McN, \McU, \McT, \McU
  - type subscripts (‚ÇÅ, ‚ÇÇ, ‚ÇÉ) in the editor via \1, \2, \3
  - type sUnion (‚ãÉ‚ÇÄ) and sInter (‚ãÇ‚ÇÄ) via \sU and \sI

-/

import Mathlib.Data.Set.Finite.Basic
import Mathlib.Data.ENNReal.Basic
import Mathlib.Data.ENNReal.Inv

set_option linter.style.commandStart false
set_option linter.style.longLine false
set_option linter.dupNamespace false

variable {X Y D: Type*}





/-

"Distance spaces" so that we can work in a generalized metric space.

- `DistanceSpaceStruct` is a class carrying just enough data to define a metric space, namely ‚â§ and + and ‚ä• (the bottom element i.e. zero)

- `DistanceSpace` gives a linear order on ‚â§ and commutative monoid structure on +, along with compatibility that ‚ä• = 0.
  - This generalized non-negative reals.

- `CompleteDistanceSpace` adds a top element ‚ä§ which is infinity for the extended reals.
  - It is compatible with the additive monoid by being absorbing, i.e. r + ‚ä§ = ‚ä§

-/

class DistanceSpaceStruct (D: Type*) extends LE D, LT D, Bot D, Add D

class DistanceSpace (D: Type*) extends AddCommMonoid D, LinearOrder D, CanonicallyOrderedAdd D, OrderBot D

class CompleteDistanceSpace (D: Type*) extends DistanceSpace D, CompleteLattice D

instance [DistanceSpace D]: DistanceSpaceStruct D := {}

instance [CompleteDistanceSpace D]: DistanceSpace D := {}

noncomputable instance: DistanceSpace NNReal := {}

noncomputable instance: CompleteDistanceSpace ENNReal := {}





/-

Three version of a metric space:

1. Given a function d: X ‚Üí X ‚Üí D, `IsMetric d` is the proposition that d is a metric.
  It is a structured proposition that comes with 4 fields, the axioms.

2. `Metric X D` is the type of all metrics on X with distance values in D.
  If `d: Metric X D` then d has two fields, `d.dist` for the distance function and `d.is_metric` for the axioms.

3. `MetricSpace D` is the type of all metric spaces valued in D.
  If `X: MetricSpace D` then `X.points` is the type of points and `X.metric` is the metric.

For the most part we can just use `IsMetric` to avoid complexity, but `Metric` is sometimes useful.

-/

structure IsMetric [DistanceSpaceStruct D] (d: X ‚Üí X ‚Üí D): Prop where
  dist_self_bot: ‚àÄ x, d x x = ‚ä•
  dist_bot_eq: ‚àÄ x y, d x y = ‚ä• ‚Üí x = y
  symmetric: ‚àÄ x y, d x y = d y x
  triangle: ‚àÄ x y z, d x z ‚â§ d x y + d y z

structure Metric (X D: Type*) [DistanceSpaceStruct D] where
  distance: X ‚Üí X ‚Üí D
  is_metric: IsMetric distance

structure MetricSpace (D: Type*) [DistanceSpaceStruct D] where
  points: Type*
  distance: points ‚Üí points ‚Üí D
  is_metric: IsMetric distance

theorem dist_zero_iff [DistanceSpace D] {d: X ‚Üí X ‚Üí D} (h: IsMetric d) {x y: X}: d x y = 0 ‚Üî x = y := by
  rw [‚Üêbot_eq_zero]
  constructor
  ¬∑ apply h.dist_bot_eq
  ¬∑ intro h1
    rw [h1, h.dist_self_bot]

theorem dist_nonzero_iff [DistanceSpace D] {d: X ‚Üí X ‚Üí D} (h: IsMetric d) {x y: X}: d x y ‚â† 0 ‚Üî x ‚â† y := by
  exact not_congr (dist_zero_iff h)

-- two points are unequal iff. their distance is positive
theorem neq_dist_pos [DistanceSpace D] {d: X ‚Üí X ‚Üí D} (hd: IsMetric d) (x y: X): x ‚â† y ‚Üî ‚ä• < d x y := by
  constructor
  ¬∑ intro h
    have := hd.dist_bot_eq x y
    have := this.mt h
    have: d x y ‚â† ‚ä• := by exact this
    have := bot_lt_iff_ne_bot.mpr this
    exact this
  ¬∑ intro h1
    have := LT.lt.ne_bot h1
    intro h2
    have: d x y = ‚ä• := by rw [h2, hd.dist_self_bot]
    contradiction





-- the discrete metric on an arbitrary type
def discrete_metric (X D: Type*) [DecidableEq X] [CompleteDistanceSpace D]: X ‚Üí X ‚Üí D :=
  fun x y => if x = y then ‚ä• else ‚ä§

theorem discrete_metric_is_metric (X: Type*) [DecidableEq X] [Nontrivial D] [CompleteDistanceSpace D]: IsMetric (discrete_metric X D) := {
  dist_self_bot := by
    intro x
    simp [discrete_metric]
  dist_bot_eq := by
    intro x y
    simp_all [discrete_metric]
    intro h
    have: ‚ä• = (0: D) := by exact bot_eq_zero
    have: ‚ä• ‚â† (‚ä§: D) := by exact bot_ne_top
    have: ‚ä§ ‚â† (0: D) := by (expose_names; exact Ne.symm (ne_of_eq_of_ne (id (Eq.symm this_1)) this))
    have := h.mt this
    simp_all
  symmetric := by
    intro x y
    simp [discrete_metric]
    by_cases x = y <;> simp_all
    intro
    simp_all
  triangle := by
    intro x y z
    by_cases x = y <;> -- tactic combinator
    by_cases x = z <;>
    by_cases y = z
    repeat simp_all [discrete_metric]
}



-- Taxicab metric: given two metrics, their sum is a metric on the product space.
noncomputable def taxicab_metric [Add D] (dX: X ‚Üí X ‚Üí D) (dY: Y ‚Üí Y ‚Üí D): X √ó Y ‚Üí X √ó Y ‚Üí D :=
  fun (x1, y1) (x2, y2) => dX x1 x2 + dY y1 y2

theorem taxicab_is_metric [DistanceSpace D] {dX: X ‚Üí X ‚Üí D} {dY: Y ‚Üí Y ‚Üí D} (hX: IsMetric dX) (hY: IsMetric dY): IsMetric (taxicab_metric dX dY) := {
  dist_self_bot := by
    intro (x, y)
    simp [taxicab_metric, hX.dist_self_bot x, hY.dist_self_bot y]
  dist_bot_eq := by
    intro (x1, y1) (x2, y2) h
    simp_all [taxicab_metric]
    constructor
    ¬∑ exact (dist_zero_iff hX).mp h.1
    ¬∑ exact (dist_zero_iff hY).mp h.2
  symmetric := by
    intro _ _
    simp [taxicab_metric]
    rw [hX.symmetric, hY.symmetric]
  triangle := sorry
}



-- product metric
-- Taxicab metric: given two metrics, their sum is a metric on the product space.
noncomputable def product_metric [Max D] (dX: X ‚Üí X ‚Üí D) (dY: Y ‚Üí Y ‚Üí D): X √ó Y ‚Üí X √ó Y ‚Üí D :=
  fun (x1, y1) (x2, y2) => max (dX x1 x2) (dY y1 y2)

theorem product_is_metric [DistanceSpace D] {dX: X ‚Üí X ‚Üí D} {dY: Y ‚Üí Y ‚Üí D} (hX: IsMetric dX) (hY: IsMetric dY): IsMetric (product_metric dX dY) := {
  dist_self_bot := by
    intro (x, y)
    simp [product_metric, hX.dist_self_bot x, hY.dist_self_bot y]
  dist_bot_eq := by
    intro (x1, y1) (x2, y2) h
    have := max_eq_bot.mp h
    simp
    constructor
    ¬∑ apply hX.dist_bot_eq
      exact this.left
    ¬∑ apply hY.dist_bot_eq
      exact this.right
  symmetric := by
    intro _ _
    simp [product_metric]
    rw [hX.symmetric, hY.symmetric]
  triangle := by
    sorry
}





def isometry (dX: X ‚Üí X ‚Üí D) (dY: Y ‚Üí Y ‚Üí D) (f: X ‚Üí Y): Prop :=
  ‚àÄ x1 x2, dX x1 x2 = dY (f x1) (f x2)

theorem isometry_id (d: X ‚Üí X ‚Üí D): isometry d d id := by
  intro _ _; rfl

theorem isometry_is_injective [DistanceSpaceStruct D] {dX: X ‚Üí X ‚Üí D} {dY: Y ‚Üí Y ‚Üí D} (hX: IsMetric dX) (hY: IsMetric dY) (f: X ‚Üí Y) (hf: isometry dX dY f): Function.Injective f := by
  intro _ _ h
  apply hX.dist_bot_eq
  rw [hf, ‚Üêh]
  apply hY.dist_self_bot





def openball [DistanceSpaceStruct D] (d: X ‚Üí X ‚Üí D) (x: X) (r: D): Set X :=
 {z | d x z < r}

def closedball [DistanceSpaceStruct D] (d: X ‚Üí X ‚Üí D) (x: X) (r: D): Set X :=
 {z | d x z ‚â§ r}

def sphere [DistanceSpaceStruct D] (d: X ‚Üí X ‚Üí D) (x: X) (r: D): Set X :=
 {z | d x z = r}

-- The open ball of radius zero is empty
theorem openball_zero_empty [DistanceSpace D] {d: X ‚Üí X ‚Üí D} (x: X): openball d x ‚ä• = ‚àÖ := by
  rw [openball]
  ext z
  constructor
  ¬∑ intro h
    apply not_le_of_gt h
    apply bot_le
  ¬∑ exact False.elim

-- x ‚àà B(x, r) iff. r > ‚ä•
theorem openball_mem_iff [DistanceSpaceStruct D] {d: X ‚Üí X ‚Üí D} (hd: IsMetric d) (x: X) (r: D): x ‚àà openball d x r ‚Üî ‚ä• < r := by
  constructor
  ¬∑ intro h
    simp [openball] at h
    rw [hd.dist_self_bot] at h
    exact h
  ¬∑ intro h
    simp [openball]
    rw [hd.dist_self_bot]
    exact h

-- The closed ball of radius zero is a singleton
theorem closedball_zero_singleton [DistanceSpace D] {d: X ‚Üí X ‚Üí D} (hd: IsMetric d) (x: X): closedball d x ‚ä• = {x} := by
  ext z
  simp [closedball]
  constructor
  ¬∑ intro h
    apply Eq.symm
    exact (dist_zero_iff hd).mp h
  ¬∑ intro h
    rw [h, ‚Üêbot_eq_zero]
    apply hd.dist_self_bot

-- In the discrete metric, if 0 < r ‚â§ ‚ä§ then B(x, r) = {x}
theorem discrete_openball_singleton [DecidableEq X] [CompleteDistanceSpace D] (x: X) {r: D} (h1: ‚ä• < r): openball (discrete_metric X D) x r = {x} := by
  ext z
  simp_all [openball]
  constructor
  ¬∑ intro h
    have := LT.lt.ne_top h
    simp_all [discrete_metric]
  ¬∑ intro h
    simp_all [discrete_metric]

-- If s = r - d(x, x0) then B(x0, s) ‚äÜ B(x, r)
theorem openball_mem_smaller_ball [DistanceSpace D] {d: X ‚Üí X ‚Üí D} (hd: IsMetric d) {x x0: X} {r: D}: openball d x0 r ‚äÜ openball d x (r + d x x0) := by
  intro z hz
  sorry
  -- calc
  --   d x z ‚â§ d x x0 + d x0 z       := by exact hd.triangle x x0 z
  --       _ < d x x0 + (r - d x x0) := by sorry
  --       _ = r                     := by sorry

-- If x0 ‚àà C(x, r)·∂ú and s = r - d(x, x0) then B(x0, s) ‚äÜ C(x, r)·∂ú
theorem closedball_compl_mem [DistanceSpace D] {d: X ‚Üí X ‚Üí D} (hd: IsMetric d) {x x0: X} {r: D} (hx0: x0 ‚àà (closedball d x r)·∂ú): openball d x0 r ‚äÜ (closedball d x (r + d x x0))·∂ú := by
  sorry

-- definition of an open set in a metric space
-- we will give them the prefix `metric_` since we need these names later
-- note its important that 0 < r in the definition of open set, even though this isnt required to be an open ball.
-- (otherwise every set is trivially open by taking r=0 at every point.)
def metric_openset [DistanceSpaceStruct D] (d: X ‚Üí X ‚Üí D) (A: Set X): Prop :=
  ‚àÄ x ‚àà A, ‚àÉ r, ‚ä• < r ‚àß openball d x r ‚äÜ A

def metric_closedset [DistanceSpaceStruct D] (d: X ‚Üí X ‚Üí D) (A: Set X): Prop :=
  metric_openset d A·∂ú

def metric_clopenset [DistanceSpaceStruct D] (d: X ‚Üí X ‚Üí D) (A: Set X): Prop :=
  metric_openset d A ‚àß metric_closedset d A

-- The empty set is clopen
theorem metric_empty_clopen [DistanceSpace D] [Nontrivial D] (d: X ‚Üí X ‚Üí D): metric_clopenset d ‚àÖ := by
  constructor
  ¬∑ intro _ _
    exists ‚ä•
  ¬∑ intro _ hx
    obtain ‚ü®r, hr‚ü© := exists_ne (‚ä•: D)
    exists r
    constructor
    ¬∑ simp_all
      exact pos_of_ne_zero hr
    ¬∑ exact fun _ _ => hx

-- If A is clopen then A·∂ú is clopen
theorem clopen_implies_compl_clopen [DistanceSpaceStruct D] (d: X ‚Üí X ‚Üí D) {A: Set X} (h: metric_clopenset d A): metric_clopenset d A·∂ú := by
  constructor
  ¬∑ exact h.right
  ¬∑ simp [metric_closedset]
    exact h.left

-- A is clopen iff. A·∂ú is clopen
theorem clopen_iff_compl_clopen [DistanceSpaceStruct D] (d: X ‚Üí X ‚Üí D) (A: Set X): metric_clopenset d A ‚Üî metric_clopenset d A·∂ú := by
  constructor
  ¬∑ exact clopen_implies_compl_clopen d
  ¬∑ intro h
    rw [‚Üêcompl_compl A]
    exact clopen_implies_compl_clopen d h

-- The whole space is clopen
theorem metric_univ_clopen [DistanceSpace D] [Nontrivial D] (d: X ‚Üí X ‚Üí D): metric_clopenset d Set.univ := by
  rw [‚ÜêSet.compl_empty]
  exact (clopen_iff_compl_clopen d ‚àÖ).mp (metric_empty_clopen d)

-- Open ball is open
-- TODO this needs work since we can't subtract..
theorem openball_open [DistanceSpace D] {d: X ‚Üí X ‚Üí D} (hd: IsMetric d) (x: X) (r: D): metric_openset d (openball d x r) := by
  intro z hz
  sorry
  -- exists r - d x z
  -- constructor
  -- ¬∑ exact tsub_pos_of_lt hz
  -- ¬∑ exact openball_mem_smaller_ball hd

-- Closed ball is closed
theorem closedball_closed [DistanceSpace D] {d: X ‚Üí X ‚Üí D} (hd: IsMetric d) (x: X) (r: D): metric_closedset d (closedball d x r) := by
  intro x0 hx0
  sorry
  -- exists d x x0 - r
  -- constructor
  -- ¬∑ simp_all [closedball]
  -- ¬∑ exact closedball_compl_mem hd hx0

-- the set of open balls in a metric space
def openballs [DistanceSpaceStruct D] (d: X ‚Üí X ‚Üí D): Set (Set X) :=
  ‚ãÉ (x: X), ‚ãÉ (r: D), {openball d x r}

theorem open_iff_sUnion_of_balls [DistanceSpace D] (d: X ‚Üí X ‚Üí D) (hd: IsMetric d) (A: Set X): metric_openset d A ‚Üî ‚àÉ ùí∞ ‚äÜ openballs d, A = ‚ãÉ‚ÇÄ ùí∞ := by
  apply Iff.intro
  ¬∑ intro h
    exists fun U => U ‚äÜ A ‚àß U ‚àà openballs d
    constructor
    ¬∑ intro U ‚ü®_, hU2‚ü©
      exact hU2
    ¬∑ ext z
      constructor
      ¬∑ intro hz
        obtain ‚ü®r, hr1, hr2‚ü© := h z hz
        exists openball d z r
        sorry
        -- repeat' constructor
        -- ¬∑ exact hr2
        -- ¬∑ exact z
      ¬∑ intro ‚ü®U, ‚ü®hU1, _‚ü©, hU3‚ü©
        exact hU1 hU3
  ¬∑ intro ‚ü®ùí∞, hùí∞1, hùí∞2‚ü©
    rw [hùí∞2]
    intro z ‚ü®U, hU1, hU2‚ü©
    have := hùí∞1 hU1
    simp_all [openballs]
    obtain ‚ü®x, r, hx‚ü© := this
    sorry
    -- exists r - d x z
    -- constructor
    -- ¬∑ rw [‚Üêhx] at hU2
    --   simp_all [openball]
    -- ¬∑ calc
    --     openball d z (r - d x z)
    --     _ ‚äÜ openball d x r := openball_mem_smaller_ball hd
    --     _ = U              := hx
    --     _ ‚äÜ ‚ãÉ‚ÇÄ ùí∞          := Set.subset_sUnion_of_subset ùí∞ U (fun ‚¶Éa‚¶Ñ a ‚Ü¶ a) hU1

-- the set of all open sets in a metric space
def metric_opensets [DistanceSpace D] (d: X ‚Üí X ‚Üí D): Set (Set X) :=
 {A | metric_openset d A}

theorem openballs_sub_opensets [DistanceSpace D] {d: X ‚Üí X ‚Üí D} (hd: IsMetric d): openballs d ‚äÜ metric_opensets d := by
  intro _ hU
  simp_all [openballs]
  obtain ‚ü®x, r, hU‚ü© := hU
  rw [‚ÜêhU]
  exact openball_open hd x r

-- Every set is open in the topology generated by the discrete metric.
theorem discrete_opensets (X D: Type*) [CompleteDistanceSpace D] [Nontrivial D] [DecidableEq X]: metric_opensets (discrete_metric X D) = Set.univ := by
  apply Set.eq_univ_of_univ_subset
  intro A hA x hx
  exists ‚ä§
  constructor
  ¬∑ exact bot_lt_top
  ¬∑ sorry -- simp [discrete_openball_singleton x bot_lt_top]

-- in a metric space, arbitrary unions of open sets are open (doesnt actually depend on d being a metric)
theorem metric_open_sUnion [DistanceSpace D] {d: X ‚Üí X ‚Üí D} {C: Set (Set X)} (h: C ‚äÜ metric_opensets d): ‚ãÉ‚ÇÄ C ‚àà metric_opensets d := by
  intro z ‚ü®U, hU1, hU2‚ü©
  obtain ‚ü®r, hr1, hr2‚ü© := h hU1 z hU2
  exists r
  constructor
  ¬∑ exact hr1
  ¬∑ exact Set.subset_sUnion_of_subset C U hr2 hU1

-- in a metric space, finite intersections of open sets are open
theorem metric_open_finite_sInter [DistanceSpace D] {d: X ‚Üí X ‚Üí D} (hd: IsMetric d) {C: Set (Set X)} (h1: C ‚äÜ metric_opensets d) (h2: Finite C): ‚ãÇ‚ÇÄ C ‚àà metric_opensets d := by
  intro z hz
  simp at hz

  -- should be able to get a finite set of radii
  sorry





/-

Definition of topological space. Like for metric spaces:
- Given a type X and a collection of subsets ùíØ, `IsTopology ùíØ` is the statement that ùíØ forms a topology.
- `Topology X` is the type of all topologies on `X`.
- `TopologicalSpace` is the type of all topological spaces.

For simplicity I guess we will work with `IsTopology` mostly.

-/

structure IsTopology (ùíØ: Set (Set X)): Prop where
  sUnion: ‚àÄ ùí∞ ‚äÜ ùíØ, ‚ãÉ‚ÇÄ ùí∞ ‚àà ùíØ
  finite_sInter: ‚àÄ ùí∞ ‚äÜ ùíØ, Finite ùí∞ ‚Üí ‚ãÇ‚ÇÄ ùí∞ ‚àà ùíØ

structure Topology (X: Type*) where
  opensets: Set (Set X)
  is_topology: IsTopology opensets

structure TopologicalSpace where
  points: Type*
  topology: Topology points

theorem empty_open {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ): ‚àÖ ‚àà ùíØ := by
  have: (‚àÖ: Set X) = ‚ãÉ‚ÇÄ ‚àÖ := by ext; simp
  rw [this]
  apply hùíØ.sUnion
  exact Set.empty_subset ùíØ

theorem univ_open {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ): Set.univ ‚àà ùíØ := by
  have: (@Set.univ X) = ‚ãÇ‚ÇÄ ‚àÖ := by ext; simp
  rw [this]
  apply hùíØ.finite_sInter
  ¬∑ exact Set.empty_subset ùíØ
  ¬∑ exact Finite.of_subsingleton

-- Binary unions and intersections of open sets are open
theorem binary_union_open {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ) {A B: Set X} (hA: A ‚àà ùíØ) (hB: B ‚àà ùíØ): A ‚à™ B ‚àà ùíØ := by
  have: A ‚à™ B = ‚ãÉ‚ÇÄ {A, B} := by ext; simp
  rw [this]
  apply hùíØ.sUnion
  exact Set.pair_subset hA hB

theorem binary_inter_open {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ) {A B: Set X} (hA: A ‚àà ùíØ) (hB: B ‚àà ùíØ): A ‚à© B ‚àà ùíØ := by
  have: A ‚à© B = ‚ãÇ‚ÇÄ {A, B} := by ext; simp
  rw [this]
  apply hùíØ.finite_sInter
  ¬∑ exact Set.pair_subset hA hB
  ¬∑ exact Finite.Set.finite_insert A {B}

-- The union of a sequence of open sets is open
theorem seq_union_open {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ) {A: ‚Ñï ‚Üí Set X} (h: ‚àÄ n, A n ‚àà ùíØ): Set.iUnion A ‚àà ùíØ := by
  apply hùíØ.sUnion
  exact Set.range_subset_iff.mpr h

-- theorem: finite intersection property is equivalent to binary intersections plus whole set
 theorem finite_inter_iff (T: Set (Set X)): (‚àÄ U ‚äÜ T, U.Finite ‚Üí ‚ãÇ‚ÇÄ U ‚àà T) ‚Üî Set.univ ‚àà T ‚àß ‚àÄ A ‚àà T, ‚àÄ B ‚àà T, A ‚à© B ‚àà T := by
  constructor
  ¬∑ intro h
    constructor
    ¬∑ rw [‚ÜêSet.sInter_empty]
      apply h
      ¬∑ apply Set.empty_subset
      ¬∑ exact Set.finite_empty
    ¬∑ intro _ hA _ hB
      rw [(Set.sInter_pair _ _).symm]
      apply h
      ¬∑ exact Set.pair_subset hA hB
      ¬∑ apply Set.toFinite
  intro ‚ü®_, hAB‚ü© _ hU1 hU2
  refine Set.Finite.induction_on_subset _ hU2 ?empty ?insert
  ¬∑ simp_all
  ¬∑ intro _ _ hS _ _ ih
    rw [Set.sInter_insert]
    apply hAB
    ¬∑ exact hU1 hS
    ¬∑ exact ih

def openset (ùíØ: Set (Set X)) (A: Set X): Prop :=
  A ‚àà ùíØ

def closedset (ùíØ: Set (Set X)) (A: Set X): Prop :=
  A·∂ú ‚àà ùíØ

def clopenset (ùíØ: Set (Set X)) (A: Set X): Prop :=
  openset ùíØ A ‚àß closedset ùíØ A

-- pointless definition but sometimes feels right
def opensets (ùíØ: Set (Set X)): Set (Set X) :=
  ùíØ

def closedsets (ùíØ: Set (Set X)): Set (Set X) :=
  {A | closedset ùíØ A}

def clopensets (ùíØ: Set (Set X)): Set (Set X) :=
  opensets ùíØ ‚à© closedsets ùíØ

theorem closedset_sInter {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ): ‚àÄ ùí∞ ‚äÜ closedsets ùíØ, ‚ãÇ‚ÇÄ ùí∞ ‚àà closedsets ùíØ := by
  sorry

theorem closedset_finite_sUnion {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ): ‚àÄ ùí∞ ‚äÜ closedsets ùíØ, Finite ùí∞ ‚Üí ‚ãÉ‚ÇÄ ùí∞ ‚àà closedsets ùíØ := by
  sorry

theorem binary_union_closed {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ) {A B: Set X} (hA: closedset ùíØ A) (hB: closedset ùíØ B): closedset ùíØ (A ‚à™ B) := by
  sorry

theorem binary_inter_closed {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ) {A B: Set X} (hA: closedset ùíØ A) (hB: closedset ùíØ B): closedset ùíØ (A ‚à© B) := by
  sorry

-- The union of a sequence of open sets is open
theorem seq_inter_closed {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ) {A: ‚Ñï ‚Üí Set X} (h: ‚àÄ n, closedset ùíØ (A n)): closedset ùíØ (Set.iInter A) := by
  sorry

-- the set of all subsets is a topology, aka the discrete topology
theorem discrete_is_topology (X: Type*): IsTopology (@Set.univ (Set X)) := {
  sUnion := by intros; trivial
  finite_sInter := by intros; trivial
}

-- the indiscrete (aka antidiscrete) topology! it is slightly less trivial to prove..
theorem indiscrete_is_topology (X: Type*): IsTopology {‚àÖ, @Set.univ X} := {
  sUnion := by apply Set.sUnion_mem_empty_univ
  finite_sInter := by
    intro ùí∞ hùí∞ _
    simp
    by_cases h: ‚àÖ ‚àà ùí∞
    ¬∑ apply Or.inl
      exact Set.subset_eq_empty (fun x hx ‚Ü¶ hx ‚àÖ h) rfl
    ¬∑ apply Or.inr
      intro _ hU
      match hùí∞ hU with
      | Or.inl h' => rw [h'] at hU; contradiction
      | Or.inr h' => exact h'
}

-- the opensets in a metric space form a topology
theorem metric_opensets_is_topology [DistanceSpace D] {d: X ‚Üí X ‚Üí D} (hd: IsMetric d): IsTopology (metric_opensets d) := {
  sUnion := by intro; exact metric_open_sUnion
  finite_sInter := by intro; exact metric_open_finite_sInter hd
}

-- given a metric on X, put a topology on X
def metric_to_topology [DistanceSpace D] (d: Metric X D): Topology X := {
  opensets := metric_opensets d.distance
  is_topology := metric_opensets_is_topology d.is_metric
}

def metrizable (ùíØ: Topology X) (D: Type*) [DistanceSpace D]: Prop :=
  ‚àÉ d: Metric X D, metric_to_topology d = ùíØ

-- the Sierpi≈Ñski topology define on Bool with {true} open
def sierpi≈Ñski_opensets: Set (Set Bool) :=
 {{}, {true}, {false, true}}

-- Helper lemma: in the sierpinski topology a set is open iff. it's subsingleton or the whole space.
theorem sierpi≈Ñski_open_iff (A: Set Bool): A ‚àà sierpi≈Ñski_opensets ‚Üî A ‚äÜ {true} ‚à® A = Set.univ := by
  constructor
  ¬∑ intro h
    rcases h with _ | _ | _
    repeat simp_all
  ¬∑ intro; simp [sierpi≈Ñski_opensets]
    by_cases false ‚àà A <;> by_cases true ‚àà A
    repeat simp_all
    ¬∑ right; left; ext x; match x with
      | false => simp_all
      | true => simp_all
    ¬∑ left; ext x; match x with
      | false => simp_all
      | true => simp_all

-- this proof was very difficult despite being a space containig 2 points...
theorem sierpi≈Ñski_is_topology: IsTopology sierpi≈Ñski_opensets := {
  sUnion := by
    intro ùí∞ hùí∞
    by_cases h: ‚àÄ U ‚àà ùí∞, U ‚äÜ {true} -- either all of them are subsingleton, or one of them is the universe
    ¬∑ apply (sierpi≈Ñski_open_iff _).mpr
      exact Or.inl (Set.sUnion_subset h)
    ¬∑ apply (sierpi≈Ñski_open_iff _).mpr
      apply Or.inr
      simp at h
      obtain ‚ü®U, hU‚ü© := h
      apply Set.univ_subset_iff.mp
      apply Set.subset_sUnion_of_subset _ U
      ¬∑ have: U = Set.univ := by
          match (sierpi≈Ñski_open_iff U).mp (hùí∞ hU.left) with
          | Or.inl _ => simp_all
          | Or.inr h => exact h
        rw [this]
      ¬∑ exact hU.left
  finite_sInter := by
    intro ùí∞ hùí∞ _ -- either all of them are universes, or at least one is subsingleton
    by_cases h: ‚àÄ U ‚àà ùí∞, U = Set.univ
    ¬∑ apply (sierpi≈Ñski_open_iff _).mpr
      exact Or.inr (Set.sInter_eq_univ.mpr h)
    ¬∑ simp at h
      obtain ‚ü®U, hU‚ü© := h
      have: U ‚äÜ {true} := by have := ((sierpi≈Ñski_open_iff U).mp (hùí∞ hU.left)); simp_all
      have: ‚ãÇ‚ÇÄ ùí∞ ‚äÜ {true} := by simp; exists U; simp_all
      apply (sierpi≈Ñski_open_iff _).mpr
      exact Or.inl this
}

def sierpi≈Ñski_topology: Topology Bool := {
  opensets := sierpi≈Ñski_opensets
  is_topology := sierpi≈Ñski_is_topology
}





-- Definition: ‚Ñ¨ is a base for ùíØ if every open set of ùíØ is a union of sets from ‚Ñ¨
def base (ùíØ ‚Ñ¨: Set (Set X)): Prop :=
  ‚Ñ¨ ‚äÜ ùíØ ‚àß ‚àÄ U ‚àà ùíØ, ‚àÉ ùí∞ ‚äÜ ‚Ñ¨, U = ‚ãÉ‚ÇÄ ùí∞

-- Every topology is a base for itself.
theorem base_self (ùíØ: Set (Set X)): base ùíØ ùíØ := by
constructor
¬∑ rfl
¬∑ intro U hU
  exists {U}
  constructor
  ¬∑ exact Set.singleton_subset_iff.mpr hU
  ¬∑ ext; simp

-- ‚Ñ¨ is a base for ùíØ iff. ‚àÄ U ‚àà ùíØ, ‚àÄ x ‚àà U, ‚àÉ B ‚àà ‚Ñ¨, x ‚àà B ‚äÜ U. Does not require ùíØ to be a topology.
theorem base_iff (ùíØ ‚Ñ¨: Set (Set X)): base ùíØ ‚Ñ¨ ‚Üî ‚Ñ¨ ‚äÜ ùíØ ‚àß ‚àÄ U ‚àà ùíØ, ‚àÄ x ‚àà U, ‚àÉ B ‚àà ‚Ñ¨, x ‚àà B ‚àß B ‚äÜ U := by
  constructor
  ¬∑ intro h
    constructor
    ¬∑ exact h.left
    ¬∑ intro U hU x hx
      obtain ‚ü®C, hC‚ü© := h.right U hU
      rw [hC.right] at hx
      obtain ‚ü®Bx, hBx‚ü© := hx
      exists Bx
      repeat' constructor
      ¬∑ exact hC.left hBx.left
      ¬∑ exact hBx.right
      ¬∑ rw [hC.right]
        intro x hx
        apply Set.mem_sUnion.mpr
        exists Bx
        constructor
        ¬∑ exact hBx.left
        ¬∑ exact hx
  ¬∑ intro h
    constructor
    ¬∑ exact h.left
    ¬∑ intro U hU
      exists {B ‚àà ‚Ñ¨ | B ‚äÜ U}
      simp
      ext x
      constructor
      ¬∑ intro hx
        obtain ‚ü®B, _, _, _‚ü© := h.right U hU x hx
        exists B
      ¬∑ intro  ‚ü®B, ‚ü®_, hB2‚ü©, hB3‚ü©
        exact hB2 hB3

-- The set ‚Ñ¨ = {{x} | x ‚àà X} is a base for the discrete topology.
theorem discrete_base (X: Type*): base (@Set.univ (Set X)) (‚ãÉ x, {x}) := by
  apply (base_iff _ _).mpr
  constructor
  ¬∑ exact fun _ _ => trivial
  ¬∑ intro U hU x hx
    exists {x}
    repeat' (apply And.intro)
    ¬∑ simp
    ¬∑ rfl
    ¬∑ exact Set.singleton_subset_iff.mpr hx

-- The set ‚Ñ¨ = {{X}} is a base for the indiscrete topology.
theorem indiscrete_base (X: Type*): base {‚àÖ, @Set.univ X} {@Set.univ X} := by
  constructor
  ¬∑ apply Set.subset_insert
  ¬∑ intro U hU
    match hU with
    | Or.inl _ => exists ‚àÖ; simp_all
    | Or.inr _ => exists {Set.univ}; simp_all

-- The set of open balls is a base for the metric topology
theorem metric_openballs_base [DistanceSpace D] {d: X ‚Üí X ‚Üí D} (hd: IsMetric d): base (metric_opensets d) (openballs d) := by
  apply (base_iff _ _).mpr
  constructor
  ¬∑ exact openballs_sub_opensets hd
  ¬∑ intro U hU x hx
    obtain ‚ü®r, hr1, hr2‚ü© := hU x hx
    exists openball d x r
    repeat' (apply And.intro)
    ¬∑ simp [openballs]
    ¬∑ exact (openball_mem_iff hd x r).mpr hr1
    ¬∑ exact hr2

-- sierpi≈Ñski base
theorem sierpi≈Ñski_base : base (sierpi≈Ñski_opensets) {{true}, {false, true}} := by
  constructor
  ¬∑ simp [sierpi≈Ñski_opensets]
  ¬∑ intro U hU
    by_cases false ‚àà U
    ¬∑ exists {{false, true}}
      constructor
      ¬∑ apply Set.subset_insert
      ¬∑ by_cases true ‚àà U <;>
          cases hU with
          | inl => simp_all
          | inr h => cases h with
            | inl => simp_all
            | inr => simp_all
    ¬∑ by_cases ht: true ‚àà U
      ¬∑ exists {{true}}
        cases hU with
        | inl => simp_all
        | inr h => cases h with
          | inl => simp_all
          | inr => simp_all
      ¬∑ exists {}
        cases hU with
        | inl => simp_all
        | inr h => cases h with
          | inl => simp_all
          | inr => simp_all

-- We say ‚Ñ¨ "is a base" if there exists a topology for which it is a base.
def is_base (‚Ñ¨: Set (Set X)): Prop :=
  ‚àÉ ùíØ, IsTopology ùíØ ‚àß base ùíØ ‚Ñ¨

-- If ùíØ is a topology then ùíØ is a base... for itself.
theorem topology_is_base {ùíØ: Set (Set X)} (h: IsTopology ùíØ): is_base ùíØ := by
  exists ùíØ
  exact ‚ü®h, base_self ùíØ‚ü©

-- If ‚Ñ¨ is a base for a topology ùíØ is a topology then ‚Ñ¨ is a base... for ùíØ.
theorem base_is_base {ùíØ ‚Ñ¨: Set (Set X)} (h1: IsTopology ùíØ) (h2: base ùíØ ‚Ñ¨): is_base ‚Ñ¨ := by
  exists ùíØ

-- Given an arbitrary collection ‚Ñ¨, `unions ‚Ñ¨` is the set of unions obtained of sets from ‚Ñ¨.
def unions (‚Ñ¨: Set (Set X)): Set (Set X) :=
  ‚ãÉ ùí∞ ‚äÜ ‚Ñ¨, {‚ãÉ‚ÇÄ ùí∞}

-- some simple theorems about `unions`
theorem unions_sub (‚Ñ¨: Set (Set X)): ‚Ñ¨ ‚äÜ unions ‚Ñ¨ := by
  intro U _
  simp [unions]
  exists {U}
  simp_all

theorem unions_mono {‚Ñ¨ ‚Ñ¨': Set (Set X)} (h: ‚Ñ¨ ‚äÜ ‚Ñ¨'): unions ‚Ñ¨ ‚äÜ unions ‚Ñ¨' := by
  simp_all [unions]
  intro B hB
  exists B
  constructor
  ¬∑ exact le_trans hB h
  ¬∑ rfl

-- the unions operator is idempotent
-- forward direction is obvious
-- for the reverse, the idea is if U = ‚ãÉ i, V i and each V i = ‚ãÉ j, B i j then U = ‚ãÉ i j, B i j
theorem unions_idem {‚Ñ¨: Set (Set X)}: unions ‚Ñ¨ = unions (unions ‚Ñ¨) := by
  apply le_antisymm
  ¬∑ apply unions_sub
  ¬∑ intro U hU
    simp_all [unions]
    obtain ‚ü®a, ha1, ha2‚ü© := hU
    simp_all
    rw [‚Üêha2]
    exists a
    sorry

theorem unions_topology {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ): ùíØ = unions ùíØ := by
  apply le_antisymm
  ¬∑ apply unions_sub
  ¬∑ intro U hU
    simp_all [unions]
    obtain ‚ü®ùí∞, hùí∞1, hùí∞2‚ü© := hU
    rw [hùí∞2]
    exact hùíØ.sUnion ùí∞ hùí∞1

theorem base_unions (‚Ñ¨: Set (Set X)): base (unions ‚Ñ¨) ‚Ñ¨ := by
  constructor
  ¬∑ apply unions_sub
  ¬∑ intro U hU
    simp_all [unions]

theorem base_iff_unions {ùíØ ‚Ñ¨: Set (Set X)}: base ùíØ ‚Ñ¨ ‚Üî ‚Ñ¨ ‚äÜ ùíØ ‚àß ùíØ = unions ‚Ñ¨ := by
  constructor
  ¬∑ intro h
    constructor
    ¬∑ exact h.left
    ¬∑ sorry
  ¬∑ sorry

-- ‚Ñ¨ is a base iff. `unions ‚Ñ¨` is a topology.
theorem is_base_iff_unions_topology (‚Ñ¨: Set (Set X)): is_base ‚Ñ¨ ‚Üî IsTopology (unions ‚Ñ¨) := by
  --simp [unions]
  apply Iff.intro
  ¬∑ intro ‚ü®ùíØ, hùíØ‚ÇÅ, hùíØ‚ÇÇ, hùíØ‚ÇÉ‚ü©
    have: ùíØ = unions ‚Ñ¨ := by
      apply le_antisymm


      sorry -- exact?
      rw [unions_topology hùíØ‚ÇÅ]
      exact unions_mono hùíØ‚ÇÇ
    rw [‚Üêthis]
    exact hùíØ‚ÇÅ
  ¬∑ intro h
    exists unions ‚Ñ¨
    constructor
    ¬∑ exact h
    ¬∑ constructor
      ¬∑ apply unions_sub
      ¬∑ simp [unions]

structure base_conditions (‚Ñ¨: Set (Set X)): Prop where
  B1: X = ‚ãÉ‚ÇÄ ‚Ñ¨
  B2: ‚àÄ B' ‚àà ‚Ñ¨, ‚àÄ B'' ‚àà ‚Ñ¨, ‚àÄ x ‚àà B' ‚à© B'', ‚àÉ B ‚àà ‚Ñ¨, x ‚àà B ‚àß B ‚äÜ B' ‚à© B''

theorem is_base_iff_base_conditions (‚Ñ¨: Set (Set X)): is_base ‚Ñ¨ ‚Üî base_conditions ‚Ñ¨ := by
  constructor
  ¬∑ intro ‚ü®T, hT‚ÇÅ, hT‚ÇÇ‚ü©
    constructor
    ¬∑ sorry
    ¬∑ intro B'  hb' B'' hB'' x hx
      sorry
  ¬∑ intro h
    sorry

-- TODO: suppose T is generated by B. Then U is open iff. forall x in U, exists B in B, x in B sub U.





def neighborhood (ùíØ: Set (Set X)) (N: Set X) (x: X): Prop :=
  ‚àÉ U ‚àà ùíØ, x ‚àà U ‚àß U ‚äÜ N

-- The whole space is a neighborhood of every point
theorem neighborhood_univ {ùíØ: Set (Set X)} (h: IsTopology ùíØ) (x: X): neighborhood ùíØ Set.univ x := by
  exists Set.univ
  simp
  exact univ_open h

-- If x ‚àà U and U is open then U is a neighborhood of x
theorem open_neighborhood (ùíØ: Set (Set X)) {U: Set X} {x: X} (h1: x ‚àà U) (h2: U ‚àà ùíØ): neighborhood ùíØ U x := by
  exists U

-- A set is open iff. it is a neighborhood of all its points.
theorem open_iff_neighborhood_of_all_points {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ) (A: Set X): A ‚àà ùíØ ‚Üî ‚àÄ x ‚àà A, neighborhood ùíØ A x := by
  constructor
  ¬∑ intro hA x hx
    exists A
  ¬∑ intro h
    have : A = ‚ãÉ‚ÇÄ {U | ‚àÉ x ‚àà A, U ‚àà ùíØ ‚àß x ‚àà U ‚àß U ‚äÜ A} := by
      ext y
      constructor
      ¬∑ intro hy
        rcases h y hy with ‚ü®U, hU, hyU, hUA‚ü©
        refine Set.mem_sUnion.mpr ‚ü®U, ?_, hyU‚ü©
        exact ‚ü®y, hy, hU, hyU, hUA‚ü©
      ¬∑ intro hy
        rcases Set.mem_sUnion.mp hy with ‚ü®U, ‚ü®x, hxA, hU, hxU, hUA‚ü©, hyU‚ü©
        exact hUA hyU
    rw [this]
    apply hùíØ.sUnion
    intro U hU
    rcases hU with ‚ü®x,hx‚ü©
    rcases hx with ‚ü®h1,h2,h3‚ü©
    exact h2

-- In the discrete topology, N is a neighborhood of x iff x ‚àà N.
theorem discrete_neighborhood_iff {X: Type*} (N: Set X) (x: X): neighborhood Set.univ N x ‚Üî x ‚àà N := by
  constructor
  ¬∑ intro ‚ü®U, _, hU2, hU3‚ü©
    exact hU3 hU2
  ¬∑ intro
    exists {x}
    simp_all

-- In the indiscrete topology, N is a neighborhood of x iff N is the whole space
theorem indiscrete_neighborhood_iff {X: Type*} (N: Set X) (x: X): neighborhood {‚àÖ, Set.univ} N x ‚Üî N = Set.univ := by
  constructor
  ¬∑ intro ‚ü®_, _, hU2, _‚ü©
    simp_all [ne_of_mem_of_not_mem' hU2]
  ¬∑ intro h
    rw [h]
    apply neighborhood_univ (indiscrete_is_topology X)

-- The set of neighborhoods of a point
def Nbhds (ùíØ: Set (Set X)) (x: X): Set (Set X) :=
 {N | neighborhood ùíØ N x}

-- neighborhood properties
-- N1: if A is a neighborhood and A ‚äÜ B then B is a neighborhood
theorem neighborhood_upward_closed {ùíØ: Set (Set X)} (x: X) {A B: Set X} (h1: neighborhood ùíØ A x) (h2: A ‚äÜ B): neighborhood ùíØ B x := by
  obtain ‚ü®U, hU1, hU2, hU3‚ü© := h1
  exists U
  repeat' constructor
  ¬∑ exact hU1
  ¬∑ exact hU2
  ¬∑ exact le_trans hU3 h2

-- N2: every finite intersection of neighborhoods is a neighborhood
theorem neighborhood_finite_inter {ùíØ: Set (Set X)} (x: X) (ùí©: Set (Set X)) (h1: ùí© ‚äÜ Nbhds ùíØ x) (h2: Finite ùí©): ‚ãÇ‚ÇÄ ùí© ‚àà Nbhds ùíØ x := by
  sorry

-- N3: x belongs to all its neighborhoods
theorem neighborhood_mem {ùíØ: Set (Set X)} {x: X} {N: Set X} (h: neighborhood ùíØ N x): x ‚àà N := by
  obtain ‚ü®_, _, hU2, hU3‚ü© := h
  exact hU3 hU2

-- N4: if V is a neighborhood of x, there exists a neighborhood W of x such that for all y in W, V is a neighborhood of y.
theorem neighborhood_N4 {ùíØ: Set (Set X)} {x: X} {V: Set X} (h: neighborhood ùíØ V x): ‚àÉ W ‚àà Nbhds ùíØ x, ‚àÄ y ‚àà W, V ‚àà Nbhds ùíØ y := sorry

-- preceding 4 properties packaged as follows:
structure neighborhood_axioms (ùí©: X ‚Üí Set (Set X)): Prop where
  upward_closed: ‚àÄ x, ‚àÄ A B: Set X, A ‚àà ùí© x ‚Üí A ‚äÜ B ‚Üí B ‚àà ùí© x
  finite_inter: ‚àÄ x, ‚àÄ ùí∞ ‚äÜ ùí© x, Finite ùí∞ ‚Üí ‚ãÇ‚ÇÄ ùí∞ ‚àà ùí© x
  point_mem: ‚àÄ x, ‚àÄ N ‚àà ùí© x, x ‚àà N
  N4: ‚àÄ x, ‚àÄ V ‚àà ùí© x, ‚àÉ W ‚àà ùí© x, ‚àÄ y ‚àà W, V ‚àà ùí© y -- rename

-- Nhbds satisties these as we just showed
theorem nbhds_obeys_neighborhood_axioms {ùíØ: Set (Set X)}: neighborhood_axioms (Nbhds ùíØ) := {
  upward_closed := neighborhood_upward_closed
  finite_inter := neighborhood_finite_inter
  point_mem := fun _ _ => neighborhood_mem
  N4 := fun _ _ => neighborhood_N4
}

def neighborhood_topology (ùí©: X ‚Üí Set (Set X)): Set (Set X) :=
 {U | ‚àÄ x ‚àà U, U ‚àà ùí© x}

theorem neighborhood_axioms_unique_topology (ùí©: X ‚Üí Set (Set X)) (hùí©: neighborhood_axioms ùí©): ‚àÉ! ùíØ, (IsTopology ùíØ ‚àß ùí© = Nbhds ùíØ) := by
  exists neighborhood_topology ùí©
  repeat' (apply And.intro)
  ¬∑ sorry -- show that `neighborhood_topology ùí©` is a topology
  ¬∑ sorry -- show that `ùí© = Nbhds (neighborhood_topology ùí©)`
  ¬∑ intro ùí©' ‚ü®h1, h2‚ü©
    sorry -- suppose ùí©' is a topology and ùí© = Nbhds ùí©', want to show ùí©' = neighborhood_topology ùí©

-- TODO: define neighrbohood topology

-- TODO: fundamental neighborhood system aka neighborhood basis





def interior_point (ùíØ: Set (Set X)) (A: Set X) (x: X): Prop :=
  neighborhood ùíØ A x

def interior (ùíØ: Set (Set X)) (A: Set X): Set X :=
 {x | interior_point ùíØ A x}

-- Interior is monotone: if A ‚äÜ B then interior(A) ‚äÜ interior(B)
theorem interior_monotone (ùíØ: Set (Set X)) {A B: Set X} (h: A ‚äÜ B): interior ùíØ A ‚äÜ interior ùíØ B := by
  simp [interior, interior_point]
  intro x hx
  exact neighborhood_upward_closed x hx h

-- Interior of the empty set is empty
theorem interior_empty (ùíØ: Set (Set X)): interior ùíØ ‚àÖ = ‚àÖ := by
  simp [interior, neighborhood, interior_point]

-- Interior of the universe is itself
theorem interior_univ {ùíØ: Set (Set X)} (h: IsTopology ùíØ): interior ùíØ Set.univ = Set.univ := by
  apply Set.eq_univ_of_univ_subset
  intro _ _
  apply neighborhood_univ h

-- Interior is a subset of the original set
theorem interior_subset_self (ùíØ: Set (Set X)) (A: Set X): interior ùíØ A ‚äÜ A := by
  exact fun _ => neighborhood_mem

-- Interior is idempotent: interior(interior(A)) = interior(A)
theorem interior_idempotent (ùíØ: Set (Set X)) (A: Set X): interior ùíØ (interior ùíØ A) = interior ùíØ A := by
  apply le_antisymm
  ¬∑ apply interior_subset_self
  ¬∑ intro _ hx
    simp_all [interior, interior_point, neighborhood]
    obtain ‚ü®U, _, _, _‚ü© := hx
    exists U
    repeat' constructor; simp_all
    intro _ _
    exists U

-- The interior is open
theorem interior_open {ùíØ: Set (Set X)} (h: IsTopology ùíØ) (A: Set X): interior ùíØ A ‚àà ùíØ := by
  apply (open_iff_neighborhood_of_all_points h (interior ùíØ A)).mpr
  intro _ hx
  obtain ‚ü®U, hU‚ÇÅ, hU‚ÇÇ, _‚ü© := hx
  exists U
  repeat' constructor
  ¬∑ exact hU‚ÇÅ
  ¬∑ exact hU‚ÇÇ
  ¬∑ intro _ _
    exists U

-- The interior of A is largest open subset of A
theorem interior_largest_open_subset {ùíØ: Set (Set X)} {A U: Set X} (h1: U ‚àà ùíØ) (h2: U ‚äÜ A): U ‚äÜ interior ùíØ A := by
  rw[interior]
  intro y hy
  refine Set.mem_setOf.mpr ?_
  rw[interior_point]
  rw[neighborhood]
  use U

-- The interior of A is the union of all open subsets of A.
-- (Is this proof beautiful or ugly?)
theorem interior_eq_union_open_subsets {ùíØ: Set (Set X)} {A: Set X}: interior ùíØ A = ‚ãÉ‚ÇÄ {U ‚àà ùíØ | U ‚äÜ A} := by
  ext
  constructor
  ¬∑ intro ‚ü®U, _, _, _‚ü©
    exists U
  ¬∑ intro ‚ü®U, ‚ü®_, _‚ü©, _‚ü©
    exists U

-- A set is open iff. it is its own interior
theorem open_iff_eq_interior {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ) (A: Set X): A ‚àà ùíØ ‚Üî A = interior ùíØ A := by
  constructor
  ¬∑ intro h
    apply Set.Subset.antisymm_iff.mpr
    constructor
    ¬∑ apply interior_largest_open_subset h; rfl
    ¬∑ apply interior_subset_self
  ¬∑ intro h
    rw [h]
    apply interior_open hùíØ


-- interior (A ‚à© B) = interior A ‚à© interior B
theorem interior_inter_eq {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ) (A B: Set X): interior ùíØ (A ‚à© B) = interior ùíØ A ‚à© interior ùíØ B := by
  ext
  constructor
  ¬∑ intro hx
    constructor
    ¬∑ exact interior_monotone ùíØ Set.inter_subset_left hx
    ¬∑ exact interior_monotone ùíØ Set.inter_subset_right hx
  ¬∑ intro ‚ü®hA, hB‚ü©
    obtain ‚ü®U, hU‚ÇÅ, hU‚ÇÇ, hU‚ÇÉ‚ü© := hA
    obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ, hV‚ÇÉ‚ü© := hB
    exists U ‚à© V
    repeat' constructor
    ¬∑ exact binary_inter_open hùíØ hU‚ÇÅ hV‚ÇÅ
    ¬∑ exact hU‚ÇÇ
    ¬∑ exact hV‚ÇÇ
    ¬∑ exact Set.inter_subset_inter hU‚ÇÉ hV‚ÇÉ

-- in the discrete topology, the interior of any set is itself
theorem discrete_interior (A: Set X): interior Set.univ A = A := by
  apply le_antisymm
  ¬∑ apply interior_subset_self
  ¬∑ intro
    apply (discrete_neighborhood_iff _ _).mpr

def adherent (ùíØ: Set (Set X)) (A: Set X) (x: X): Prop :=
  ‚àÄ N ‚àà Nbhds ùíØ x, Set.Nonempty (N ‚à© A)

def closure (ùíØ: Set (Set X)) (A: Set X): Set X :=
 {x | adherent ùíØ A x}

-- Duality: closure(A) = interior(A·∂ú)·∂ú
-- Lets us prove results about closure in terms of interior
-- TODO: this proof is ugly!
theorem closure_eq (ùíØ: Set (Set X)) (A: Set X): closure ùíØ A = (interior ùíØ A·∂ú)·∂ú := by
  ext
  constructor
  ¬∑ intro hx
    simp_all [interior, neighborhood, interior_point]
    intro U h1 h2 h3
    have := hx U (open_neighborhood ùíØ h2 h1)
    have: U ‚à© A = ‚àÖ := by -- this should be easier..
      ext
      constructor
      ¬∑ intro ‚ü®hz1, hz2‚ü©
        exact h3 hz1 hz2
      ¬∑ exact False.elim
    sorry -- contradiction
  ¬∑ sorry
    -- intro hx N hN h
    -- obtain ‚ü®U, hU‚ÇÅ, hU‚ÇÇ, hU‚ÇÉ‚ü© := hN
    -- simp_all [interior, neighborhood, interior_point]
    -- apply hx U hU‚ÇÅ hU‚ÇÇ
    -- intro _ hz1 hz2
    -- have := Set.mem_inter (hU‚ÇÉ hz1) hz2
    -- rw [h] at this
    -- contradiction

theorem closure_empty {ùíØ: Set (Set X)} (h: IsTopology ùíØ): closure ùíØ ‚àÖ = ‚àÖ := by
  simp [closure_eq, interior_univ h]

theorem closure_univ (ùíØ: Set (Set X)): closure ùíØ Set.univ = Set.univ := by
  simp [closure_eq, interior_empty]

theorem closure_compl_eq_compl_interior (ùíØ: Set (Set X)) (A: Set X): closure ùíØ A·∂ú = (interior ùíØ A)·∂ú := by
  simp [closure_eq]

theorem compl_closure_eq_interior_compl (ùíØ: Set (Set X)) (A: Set X): (closure ùíØ A)·∂ú = interior ùíØ A·∂ú := by
  simp [closure_eq]

theorem closure_monotone (ùíØ: Set (Set X)) (A B: Set X){h:A‚äÜ B}: closure ùíØ A ‚äÜ closure ùíØ B := by
simp[closure, adherent]
intro x hx
intro U hU
apply hx at hU
have h1: U ‚à© A ‚äÜ U ‚à© B := by
  exact Set.inter_subset_inter (fun ‚¶Éa‚¶Ñ a ‚Ü¶ a) h
exact Set.Nonempty.mono h1 hU

theorem closure_interior (ùíØ: Set (Set X)) (A: Set X): closure ùíØ (interior ùíØ A) ‚äÜ closure ùíØ A := by
  apply closure_monotone
  apply interior_subset_self

theorem closure_idempotent (ùíØ: Set (Set X)) (A: Set X): closure ùíØ (closure ùíØ A) = closure ùíØ A := by
  simp [closure_eq, interior_idempotent]

-- the closure is closed
theorem closure_closed {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ) (A: Set X): closedset ùíØ (closure ùíØ A) := by
  simp [closure_eq, closedset]
  apply interior_open hùíØ

-- closure is a superset of the original
theorem closure_supset_self (ùíØ: Set (Set X)) (A: Set X): A ‚äÜ closure ùíØ A := by
  simp [closure_eq]
  apply Set.subset_compl_comm.mpr
  apply interior_subset_self

-- The closure of A is smallest closed supset of A
theorem closure_smallest_closed_supset {ùíØ: Set (Set X)} {A U: Set X} (h1: U·∂ú ‚àà ùíØ) (h2: A ‚äÜ U): closure ùíØ A ‚äÜ U := by
  simp [closure_eq]
  have: U·∂ú ‚äÜ A·∂ú := Set.compl_subset_compl_of_subset h2
  have := interior_largest_open_subset h1 this
  exact Set.compl_subset_comm.mp this

theorem closure_eq_inter_closed_supsets {ùíØ: Set (Set X)} {A: Set X}: closure ùíØ A = ‚ãÇ‚ÇÄ {U | U·∂ú ‚àà ùíØ ‚àß A ‚äÜ U} := by
  simp [closure_eq]
  apply compl_inj_iff.mp
  simp
  rw [interior_eq_union_open_subsets]
  sorry

theorem closed_iff_eq_closure {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ) (A: Set X): closedset ùíØ A ‚Üî A = closure ùíØ A := by
  simp [closure_eq, closedset]
  calc
    A·∂ú ‚àà ùíØ ‚Üî A·∂ú  = interior ùíØ A·∂ú      := by apply open_iff_eq_interior hùíØ
         _ ‚Üî A·∂ú·∂ú = (interior ùíØ A·∂ú)·∂ú   := by apply symm compl_inj_iff
         _ ‚Üî A   = (interior ùíØ A·∂ú)·∂ú   := by rw [compl_compl]

-- closure (A ‚à™ B) = (closure A) ‚à™ (closure B)
theorem closure_union_eq {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ) (A B: Set X): closure ùíØ (A ‚à™ B) = closure ùíØ A ‚à™ closure ùíØ B := by
  simp [closure_eq]
  apply compl_inj_iff.mp
  simp
  apply interior_inter_eq hùíØ

-- in the discrete topology, the closure of any set is itself
theorem discrete_closure (A: Set X): closure Set.univ A = A := by
  simp [closure_eq, discrete_interior]

-- the frontier, aka boundary
def frontier_point (ùíØ: Set (Set X)) (A: Set X) (x: X): Prop :=
  ‚àÄ N ‚àà Nbhds ùíØ x, Set.Nonempty (N ‚à© A) ‚àß Set.Nonempty (N ‚à© A·∂ú)

def frontier (ùíØ: Set (Set X)) (A: Set X): Set X :=
  {x | frontier_point ùíØ A x}

theorem frontier_eq (ùíØ: Set (Set X)) (A: Set X): frontier ùíØ A = closure ùíØ A ‚à© closure ùíØ A·∂ú := by
  simp [frontier, frontier_point, closure, adherent]
  ext
  exact forall‚ÇÇ_and

-- the frontier of the closure is the same as the frontier
theorem frontier_closure_eq (ùíØ: Set (Set X)) (A: Set X): frontier ùíØ (closure ùíØ A) = frontier ùíØ A := by
  calc
    frontier ùíØ (closure ùíØ A) = closure ùíØ (closure ùíØ A) ‚à© closure ùíØ (closure ùíØ A)·∂ú := by rw [frontier_eq]
                           _ = closure ùíØ A ‚à© closure ùíØ (closure ùíØ A)·∂ú := by rw [closure_idempotent]
                           _ = closure ùíØ A ‚à© closure ùíØ (interior ùíØ A·∂ú) := by rw [compl_closure_eq_interior_compl]
                           _ = closure ùíØ A ‚à© closure ùíØ A·∂ú := by sorry
                           _ = frontier ùíØ A := by rw [frontier_eq]

theorem frontier_closed (ùíØ: Set (Set X)) (A: Set X): closedset ùíØ (frontier ùíØ A) := by
  sorry

-- TODO: is basic neighborhood worth defining?
theorem frontier_mem_iff {ùíØ ‚Ñ¨: Set (Set X)} (h: base ùíØ ‚Ñ¨) (A: Set X) (x: X): x ‚àà frontier ùíØ A ‚Üî ‚àÄ N ‚àà Nbhds ùíØ x ‚à© ‚Ñ¨, N ‚à© A = ‚àÖ ‚àß N ‚à© A·∂ú = ‚àÖ := by
  sorry

theorem frontier_univ {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ): frontier ùíØ Set.univ = ‚àÖ := by
  simp [frontier_eq, closure_empty hùíØ]

theorem frontier_empty {ùíØ: Set (Set X)} (hùíØ: IsTopology ùíØ): frontier ùíØ ‚àÖ = ‚àÖ := by
  simp [frontier_eq, closure_empty hùíØ]

-- in a metric space, the frontier of the open ball is the sphere
theorem frontier_openball [DistanceSpace D] {d: X ‚Üí X ‚Üí D} (hd: IsMetric d) (x: X) (r: D): frontier (metric_opensets d) (openball d x r) = sphere d x r := by
  sorry

-- in the discrete topology, the frontier of every set is empty
theorem discrete_frontier (A: Set X): frontier Set.univ A = ‚àÖ := by
  simp [frontier_eq, discrete_closure]

def exterior_point (ùíØ: Set (Set X)) (A: Set X) (x: X): Prop :=
  x ‚àà interior ùíØ A·∂ú

def exterior (ùíØ: Set (Set X)) (A: Set X): Set X :=
  {x | exterior_point ùíØ A x}

theorem exterior_eq (ùíØ: Set (Set X)) (A: Set X): exterior ùíØ A = (closure ùíØ A)·∂ú := by
  simp [exterior, exterior_point, compl_closure_eq_interior_compl]

-- TODO this is clunky
-- the interior, frontier, and exterior form a disjoint union of the whole space.
theorem interior_frontier_exterior_partition (ùíØ: Set (Set X)) (A: Set X):
  (interior ùíØ A ‚à™ frontier ùíØ A ‚à™ exterior ùíØ A = X) ‚àß (interior ùíØ A ‚à© frontier ùíØ A = ‚àÖ) ‚àß (interior ùíØ A ‚à© exterior ùíØ A = ‚àÖ) ‚àß (frontier ùíØ A ‚à© exterior ùíØ A = ‚àÖ) := by
  repeat' constructor
  ¬∑ sorry
  ¬∑ sorry
  ¬∑ sorry
  ¬∑ sorry

-- in the discrete topology, the exterior of a set is its complement
theorem discrete_exterior (ùíØ: Set (Set X)) (A: Set X): exterior Set.univ A = A·∂ú := by
  simp [exterior_eq, closure_eq, discrete_interior]

theorem closure_eq_interior_union_frontier (ùíØ: Set (Set X)) (A: Set X): closure ùíØ A = interior ùíØ A ‚à™ frontier ùíØ A := by
  sorry

theorem interior_eq_set_minus_frontier (ùíØ: Set (Set X)) (A: Set X): interior ùíØ A = A \ frontier ùíØ A := by
  sorry





def dense (ùíØ: Set (Set X)) (A: Set X): Prop :=
  ‚àÄ U ‚àà ùíØ, Set.Nonempty U ‚Üí Set.Nonempty (A ‚à© U)

theorem dense_univ (ùíØ: Set (Set X)): dense ùíØ Set.univ := by
  simp [dense]

theorem dense_iff_dense_in_base (ùíØ ‚Ñ¨: Set (Set X)) (h: base ùíØ ‚Ñ¨) (A: Set X): dense ùíØ A ‚Üî ‚àÄ U ‚àà ‚Ñ¨, Set.Nonempty U ‚Üí Set.Nonempty (A ‚à© U) := by
  sorry

-- some theorems ? Q is dense, I is dense, is C is countable then C·∂ú is dense

theorem discrete_dense_iff (A: Set X): dense Set.univ A ‚Üî A = Set.univ := by
  constructor
  ¬∑ intro h
    apply Set.eq_univ_of_univ_subset
    intro x _
    simp [dense] at h
    exact Set.inter_singleton_nonempty.mp (h {x} (by exists x))
  ¬∑ intro h
    rw [h]
    apply dense_univ

theorem indiscrete_dense (A: Set X): Set.Nonempty A ‚Üí dense {‚àÖ, Set.univ} A := by
  intro h
  simp [dense]
  intro--
  exact h

-- theorem : dense in euclidean topology iff. dense in sorgenfry
theorem dense_iff (ùíØ: Set (Set X)) (A: Set X): dense ùíØ A ‚Üî closure ùíØ A = Set.univ := by
  constructor
  ¬∑ intro h
    apply Set.eq_univ_of_univ_subset
    intro x _
    simp_all [closure, adherent, dense]
    intro N hN
    simp_all [Nbhds, neighborhood]
    obtain ‚ü®U, hU1, hU2, hU3‚ü© := hN
    have := h U hU1 (by exists x)
    rw [Set.inter_comm]
    exact Set.Nonempty.mono (Set.inter_subset_inter (fun ‚¶Éa‚¶Ñ a ‚Ü¶ a) hU3) this
  ¬∑ intro h
    simp [dense]
    intro U hU1 hU2
    simp_all [closure, adherent]
    obtain ‚ü®x, hx‚ü© := hU2
    have: x ‚àà Set.univ := by exact trivial
    rw [‚Üêh] at this
    simp at this
    have: ‚àÄ N ‚àà Nbhds ùíØ x, (N ‚à© A).Nonempty := this
    have: U ‚àà Nbhds ùíØ x := by
      simp [Nbhds]
      exact open_neighborhood ùíØ hx hU1
    rw [Set.inter_comm]
    (expose_names; exact this_1 U this)

theorem dense_antimono {ùíØ‚ÇÅ ùíØ‚ÇÇ: Set (Set X)} (h1: ùíØ‚ÇÅ ‚äÜ ùíØ‚ÇÇ) {A: Set X} (h2: dense ùíØ‚ÇÇ A): dense ùíØ‚ÇÅ A := by
  intro U hU1
  exact h2 U (h1 hU1)

-- example: Z is dense in the topology generated by [a,infty)





-- fr√©chet and hausdorff spaces
def fr√©chet (ùíØ: Set (Set X)): Prop :=
  ‚àÄ x y, x ‚â† y ‚Üí ‚àÉ U V, U ‚àà Nbhds ùíØ x ‚àß V ‚àà Nbhds ùíØ y ‚àß x ‚àâ V ‚àß y ‚àâ U

-- a family ùíØ is hausdorff (aka T2) if every pair of distinct points have disjoint neighborhoods.
def hausdorff (ùíØ: Set (Set X)): Prop :=
  ‚àÄ x y, x ‚â† y ‚Üí ‚àÉ U V, U ‚àà Nbhds ùíØ x ‚àß V ‚àà Nbhds ùíØ y ‚àß Disjoint U V

theorem fr√©chet_implies_hausdorff (ùíØ: Set (Set X)): hausdorff ùíØ ‚Üí fr√©chet ùíØ := by
  intro h x y h1
  obtain ‚ü®U, V, hU1, hV1, h2‚ü© := h x y h1
  exists U, V
  repeat' (apply And.intro)
  ¬∑ exact hU1
  ¬∑ exact hV1
  ¬∑ exact Disjoint.notMem_of_mem_left h2 (neighborhood_mem hU1)
  ¬∑ exact Disjoint.notMem_of_mem_left (id (Disjoint.symm h2)) (neighborhood_mem hV1)

-- the discrete topology is hausdorff
theorem discrete_hausdorff (X: Type*): hausdorff (@Set.univ (Set X)) := by
  intro x y h
  exists {x}, {y}
  repeat' (apply And.intro)
  ¬∑ exact (discrete_neighborhood_iff {x} x).mpr rfl
  ¬∑ exact (discrete_neighborhood_iff {y} y).mpr rfl
  ¬∑ exact Set.disjoint_singleton.mpr h

-- If X has more than 1 point, the indiscrete topology is nonhausdorff
theorem indiscrete_nonhausdorff {X: Type*} {x y: X} (h: x ‚â† y): ¬¨ hausdorff {‚àÖ, @Set.univ X} := by
  simp [hausdorff]
  exists x, y
  constructor
  ¬∑ exact h
  ¬∑ intro U hU
    simp_all [Nbhds, neighborhood]
    exact Nonempty.intro x

-- the indiscrete space is hausdorff iff. X has one point
theorem indiscrete_nonhausdorff_iff (X: Type*): hausdorff {‚àÖ, @Set.univ X} ‚Üî ‚àÄ x y: X, x = y := by
  sorry

-- Sierpi≈Ñski space is non-hausdorff
theorem sierpi≈Ñski_nonhausdorff: ¬¨hausdorff (sierpi≈Ñski_topology.opensets) := by
  apply not_forall.mpr
  exists true
  apply not_forall.mpr
  exists false
  simp
  intro _ ht _ hf
  obtain ‚ü®U, hU1, _, hU3‚ü© := hf
  simp [Disjoint]
  exists {true}
  simp
  repeat' constructor
  ¬∑ exact neighborhood_mem ht
  ¬∑ have: U = {false, true} := by
      rcases hU1 with _ | _ | _
      repeat simp_all
    apply hU3
    simp_all

-- If r > 0 then B(x, r) is a neighborhood of x. TODO: move somewhere else
theorem openball_neighborhood [DistanceSpace D] {d: X ‚Üí X ‚Üí D} (hd: IsMetric d) (x: X) {r: D} (hr: 0 < r): neighborhood (metric_opensets d) (openball d x r) x := by
  exists (openball d x r)
  sorry
  -- repeat' constructor
  -- ¬∑ exact openball_open hd x r
  -- ¬∑ sorry -- exact?-- (openball_mem_iff hd x).mpr hr
  -- ¬∑ sorry -- exact?

-- simple lemma: if balls are too far apart, their intersection is empty.
lemma separated_balls [DistanceSpace D] {d: X ‚Üí X ‚Üí D} (hd: IsMetric d) {x1 x2: X} {r1 r2: D} (h: r1 + r2 ‚â§ d x1 x2): Disjoint (openball d x1 r1) (openball d x2 r2) := by
  apply Set.disjoint_iff.mpr
  intro x ‚ü®hx1, hx2‚ü©
  apply not_lt_of_ge h
  calc
    d x1 x2 ‚â§ d x1 x + d x x2 := by exact hd.triangle x1 x x2
          _ = d x1 x + d x2 x := by rw [hd.symmetric x x2]
          _ < r1 + r2 := by sorry -- exact? -- add_lt_add hx1 hx2

-- Every metric space is hausdorff.
-- Proof: given two distinct points x, y, let r = d(x, y) / 2. Then B(x, r) and B(y, r) are disjoint neighborhoods.
theorem metric_space_hausdorff {d: X ‚Üí X ‚Üí ENNReal} (hd: IsMetric d): hausdorff (metric_opensets d) := by
  intro x y neq
  let r := d x y / 2
  have: d x y ‚â† 0 := (dist_nonzero_iff hd).mpr neq
  have r_pos: 0 < r := ENNReal.half_pos this
  exists openball d x r, openball d y r
  repeat' (apply And.intro)
  ¬∑ exact openball_neighborhood hd x r_pos
  ¬∑ exact openball_neighborhood hd y r_pos
  ¬∑ simp [separated_balls hd, r]

-- If a space is not hausdorff, it is not metrizable
theorem nonhausdorff_nonmetrizable {ùíØ: Topology X} (h: ¬¨ hausdorff ùíØ.opensets): ¬¨ metrizable ùíØ ENNReal := by
  intro ‚ü®d, hd‚ü©
  rw [‚Üêhd] at h
  exact h (metric_space_hausdorff d.is_metric)

-- corollary: sierpi≈Ñski space is nonmetrizable!
theorem sierpi≈Ñski_nonmetrizable: ¬¨ metrizable sierpi≈Ñski_topology ENNReal := by
  exact nonhausdorff_nonmetrizable sierpi≈Ñski_nonhausdorff

-- TODO
-- show the cofinite topology is Frechet but not Hausdorff
-- the antidiscrete space is not frechte
-- Let O1, O2 be topologies. If O1 ‚äÜ O2 then O1 (Hausdorff/Frechet) implies O2 (Hausdorff/Frechet)

theorem frechet_iff (ùíØ: Set (Set X)): fr√©chet ùíØ ‚Üî ‚àÄ x, closedset ùíØ {x} := by
  sorry

-- show topology generated by [a, infty) is Frechet but not Hausdorff
-- we can call this the LCRI topology (left closed right infinite) or maybe just OI
def LCRI_base: Set (Set ENNReal) :=
  ‚ãÉ (a: ENNReal), {Set.Ici a}

theorem LCRI_base_is_base: is_base LCRI_base := by
  sorry

theorem frechet_iff' (T: Set (Set X)): fr√©chet T ‚Üî ‚àÄ x, {x} = Set.sInter (Nbhds T x) := by
  sorry





def subspace_topology (T: Set (Set X)) (A: Set X): Set (Set X) :=
  {A ‚à© U | U ‚àà T}

theorem subspace_topology_is_topology (T: Set (Set X)) (A: Set X) (hT: IsTopology T): IsTopology (subspace_topology T A) := by
  sorry

-- basis of a subspace

-- properties of topologies of metric spaces

-- product topology

-- equivalence of metrics

-- diagonal is closed iff hausdorff
def diagonal (X: Type*): Set (X √ó X) :=
  Set.image (fun x => (x, x)) Set.univ

theorem hausdorff_iff_diagonal_closed (T: Set (Set (X √ó X))): hausdorff T ‚Üî closedset T (diagonal X) := by
  sorry





-- continuity
def continuous_at (TX: Set (Set X)) (TY: Set (Set Y)) (f: X ‚Üí Y) (x: X): Prop :=
  ‚àÄ N' ‚àà Nbhds TY (f x), ‚àÉ N ‚àà Nbhds TX x, f '' N ‚äÜ N'

def continuous (TX: Set (Set X)) (TY: Set (Set Y)) (f: X ‚Üí Y): Prop :=
  ‚àÄ x, continuous_at TX TY f x

def continuous_iff_open_preimage_open (TX: Set (Set X)) (TY: Set (Set Y)) (f: X ‚Üí Y): continuous TX TY f ‚Üî ‚àÄ V ‚àà TY, Set.preimage f V ‚àà TX := by
  sorry

def continuous_iff_closed_preimage_closed (TX: Set (Set X)) (TY: Set (Set Y)) (f: X ‚Üí Y): continuous TX TY f ‚Üî ‚àÄ F ‚àà closedsets TY, Set.preimage f F ‚àà closedsets TX := by
  sorry

def continuous_iff_image_closure_subseteq_closure_image (TX: Set (Set X)) (TY: Set (Set Y)) (f: X ‚Üí Y): continuous TX TY f ‚Üî ‚àÄ A: Set X, Set.image f (closure TX A) ‚äÜ closure TY (Set.image f A) := by
  sorry





noncomputable def Function.Inverse {f: X ‚Üí Y} (h: Function.Bijective f): Y ‚Üí X :=
  Classical.choose (Function.bijective_iff_has_inverse.mp h)

-- homeomorphisms
structure homeomorphism (TX: Set (Set X)) (TY: Set (Set Y)) (f: X ‚Üí Y): Prop where
  bijection: Function.Bijective f
  continuous_forward: continuous TX TY f
  continuous_inverse: continuous TY TX (Function.Inverse bijection)

def homeomorphic (TX: Set (Set X)) (TY: Set (Set Y)): Prop :=
  ‚àÉ f, homeomorphism TX TY f

-- this definition doesn't care about underlying type of points
def homeomorphic_spaces (X Y: TopologicalSpace): Prop :=
  ‚àÉ f: X.points ‚Üí Y.points, homeomorphism X.topology.opensets Y.topology.opensets f

-- a property is called a topological property if it's preserved under homeomorphism
def topological_property (P: TopologicalSpace ‚Üí Prop): Prop :=
  ‚àÄ X Y: TopologicalSpace, homeomorphic_spaces X Y ‚Üí P X ‚Üí P Y

def connected (T: Set (Set X)): Prop :=
  ‚àÄ U V: Set X, U ‚àà T ‚Üí V ‚àà T ‚Üí U.Nonempty ‚Üí V.Nonempty ‚Üí U ‚à™ V = Set.univ ‚Üí (U ‚à© V).Nonempty

def connected_space (X: TopologicalSpace): Prop :=
  connected X.topology.opensets

-- connectedness is a topological property
theorem connected_topological_property: topological_property connected_space := by
  intro X Y h hX U V hU1 hV1 hU2 hV2 hUV
  sorry -- lol

-- let f: X ‚Üí Y be a homeomorphism. Then f induces a homeomorphism X \ A -> Y \ f(A)





-- limit of a sequence in terms of the tail
def tail (x: Nat ‚Üí X) (t: Nat): Nat ‚Üí X :=
  fun n => x (t + n)

def converges (T: Set (Set X)) (x: Nat ‚Üí X) (l: X): Prop :=
  ‚àÄ N ‚àà Nbhds T l, ‚àÉ t: Nat, Set.range (tail x t) ‚äÜ N

def convergent (T: Set (Set X)) (x: Nat ‚Üí X): Prop :=
  ‚àÉ l, converges T x l

def converges_distance [DistanceSpaceStruct D] (d: X ‚Üí X ‚Üí D) (x: Nat ‚Üí X) (l: X): Prop :=
  ‚àÄ r, ‚ä• < r ‚Üí ‚àÉ t, Set.range (tail x t) ‚äÜ openball d l r

def convergent_distance [DistanceSpaceStruct D] (d: X ‚Üí X ‚Üí D) (x: Nat ‚Üí X): Prop :=
  ‚àÉ l, converges_distance d x l

-- equivalent definition in a metric space
theorem limit_metric_iff [DistanceSpace D] (d: X ‚Üí X ‚Üí D) (x: Nat ‚Üí X) (l: X): converges (metric_opensets d) x l ‚Üî converges_distance d x l := by
  sorry

def adherent_value (T: Set (Set X)) (x: Nat ‚Üí X) (a: X): Prop :=
  ‚àÄ N ‚àà Nbhds T a, ‚àÄ t, (Set.range (tail x t) ‚à© N).Nonempty

-- defn of a subsequence

-- a is adherent iff exists subsequence converging to a

-- limits are unique in a hausdorff space
theorem hausdorff_limit_unique (T: Set (Set X)) (h: hausdorff T) (x: Nat ‚Üí X) (l1 l2: X) (h1: converges T x l1) (h2: converges T x l2): l1 = l2 := by
  sorry

-- prop: adherent points preserved by sequences

-- the set of adherent values are closed

-- defn of countable/denumerable set





-- diameter of a set
noncomputable def diameter [CompleteDistanceSpace D] (d: X ‚Üí X ‚Üí D) (A: Set X): D :=
  sSup (‚ãÉ (a ‚àà A) (b ‚àà A), {d a b})

theorem diameter_monotone [CompleteDistanceSpace D] (d: X ‚Üí X ‚Üí D) {A B: Set X} (h: A ‚äÜ B): diameter d A ‚â§ diameter d B := by
  sorry

theorem diameter_singleton [CompleteDistanceSpace D] {d: X ‚Üí X ‚Üí D} (hd: IsMetric d) (x: X): diameter d {x} = 0 := by
  simp [diameter, hd.dist_self_bot x]

example [CompleteDistanceSpace D] (d: X ‚Üí X ‚Üí D): diameter d ‚àÖ = 0 := by
  simp [diameter]

example [CompleteDistanceSpace D] {d: X ‚Üí X ‚Üí D} (hd: IsMetric d) (x y: X): diameter d {x, y} = d x y := by
  simp [diameter]
  sorry

example [CompleteDistanceSpace D] (d: X ‚Üí X ‚Üí D) (hd: IsMetric d) (x: X) (r: D): diameter d (openball d x r) ‚â§ 2 ‚Ä¢ r := by
  simp [diameter]
  intros
  have := hd.triangle
  sorry

-- a set is bounded if it has finite diameter.
def bounded [CompleteDistanceSpace D] (d: X ‚Üí X ‚Üí D) (A: Set X): Prop :=
  diameter d A < ‚ä§

-- a set is boudned iff. it is contained in a ball of finite radius.
-- maybe closed ball easier.
theorem bounded_iff [CompleteDistanceSpace D] (d: X ‚Üí X ‚Üí D) (A: Set X): bounded d A ‚Üî ‚àÉ x r, r < ‚ä§ ‚àß A ‚äÜ openball d x r := by
  sorry

theorem bounded_subset [CompleteDistanceSpace D] (d: X ‚Üí X ‚Üí D) {A B: Set X} (h1: A ‚äÜ B) (h2: bounded d B): bounded d A := by
  exact lt_of_le_of_lt (diameter_monotone _ h1) h2

-- TODO if a finite family is all bounded their union is bounded.
theorem bounded_finite_union [CompleteDistanceSpace D] (d: X ‚Üí X ‚Üí D) (F: Set (Set X)) (h1: Finite F) (h2: ‚àÄ A ‚àà F, bounded d A): bounded d (‚ãÉ‚ÇÄ F) := by
  sorry

def totally_bounded [CompleteDistanceSpace D] (d: X ‚Üí X ‚Üí D) (A: Set X): Prop :=
  ‚àÄ Œµ, ‚ä• < Œµ ‚Üí ‚àÉ C: Set X, Finite C ‚àß A ‚äÜ ‚ãÉ (x ‚àà C), openball d x Œµ

theorem totally_bounded_bounded [CompleteDistanceSpace D] {d: X ‚Üí X ‚Üí D} {A: Set X} (h: totally_bounded d A): bounded d A := by
  sorry





-- cauchy sequence in terms of diameters of tails
def cauchy [DistanceSpaceStruct D] (d: X ‚Üí X ‚Üí D) (x: Nat ‚Üí X): Prop :=
  ‚àÄ Œµ, ‚ä• < Œµ ‚Üí ‚àÉ t, ‚àÄ m n, t ‚â§ m ‚Üí t ‚â§ n ‚Üí d (x m) (x n) < Œµ

def cauchy_sequence_diameter [CompleteDistanceSpace D] (d: X ‚Üí X ‚Üí D) (x: Nat ‚Üí X): cauchy d x ‚Üî ‚àÄ r, ‚ä• < r ‚Üí ‚àÉ t, diameter d (Set.range (tail x t)) < r := by
  sorry

theorem convergent_cauchy [DistanceSpaceStruct D] {d: X ‚Üí X ‚Üí D} {x: Nat ‚Üí X} (h: convergent_distance d x): cauchy d x := by
  sorry

example [DistanceSpace D] {d: X ‚Üí X ‚Üí D} {x: Nat ‚Üí X} {a: X} (h1: cauchy d x) (h2: adherent_value (metric_opensets d) x a): converges_distance d x a := by
  sorry

def complete [DistanceSpaceStruct D] (d: X ‚Üí X ‚Üí D): Prop :=
  ‚àÄ x, cauchy d x ‚Üí convergent_distance d x

-- If A ‚äÜ X is complete then it is closed.
-- todo : use subspace metric?
example [DistanceSpaceStruct D] (d: X ‚Üí X ‚Üí D) (A: Set X) (h: complete (fun (a b: A) => d a b)): metric_closedset d A := by
  sorry

example [DistanceSpaceStruct D] (d: X ‚Üí X ‚Üí D) (A: Set X) (h1: complete d) (h2: metric_closedset d A): complete (fun (a b: A) => d a b) := by
  sorry

-- If two metrics are uniformly equivalent, then Cauchy iff Cauchy.
-- Hence complete iff complete.

-- If dX, dY complete then dX x dY (the product metric given by max) is complete

structure Completion [DistanceSpace D] {X0 X1: Type*} (d0: X0 ‚Üí X0 ‚Üí D) (d1: X1 ‚Üí X1 ‚Üí D) (i: X0 ‚Üí X1): Prop where
  isometry: isometry d0 d1 i
  dense: dense (metric_opensets d1) (Set.range i)
  complete: complete d1

-- Appendix TODO move
-- given a metric space, extend to disctance on sets

noncomputable def distance_point_set [CompleteDistanceSpace D] (d: X ‚Üí X ‚Üí D) (a: X) (B: Set X): D :=
  sInf (‚ãÉ (b ‚àà B), {d a b})

noncomputable def distance_set_point [CompleteDistanceSpace D] (d: X ‚Üí X ‚Üí D) (A: Set X) (b: X): D :=
  sInf (‚ãÉ (a ‚àà A), {d a b})

noncomputable def set_dist [CompleteDistanceSpace D] (d: X ‚Üí X ‚Üí D) (A B: Set X): D :=
  sInf (‚ãÉ (a ‚àà A) (b ‚àà B), {d a b})

-- noncomputable def hausdorff_dist (d: X ‚Üí X ‚Üí D) (A B: Set X): D :=
--   max (sSup ‚ãÉ (x: )) ()


-- structure IsPseudoExtendedMetric (d: X ‚Üí X ‚Üí D): Prop where
--   eq: ‚àÄ x, d x x = 0
--   symm: ‚àÄ x y, d x y = d y x
--   triangle: ‚àÄ x y z, d x z ‚â§ d x y + d y z

-- example (d: X ‚Üí X ‚Üí D): IsMetric (set_dist d) := {
--   eq_iff := sorry -- fails
--   symm := by
--     intro A B
--     simp [set_dist]
--     sorry
--   triangle := by
--     sorry
-- }
