
import Mathlib.Data.Set.Finite.Basic
import Mathlib.Data.ENNReal.Basic
import Mathlib.Data.ENNReal.Inv


import basic_topology.T0_topology
import basic_topology.T1_metric

set_option linter.style.commandStart false
set_option linter.style.longLine false
set_option linter.dupNamespace false

variable {X Y D: Type*}





-- frÃ©chet and hausdorff spaces
def frÃ©chet (ğ’¯: Set (Set X)): Prop :=
  âˆ€ x y, x â‰  y â†’ âˆƒ U V, U âˆˆ Nbhds ğ’¯ x âˆ§ V âˆˆ Nbhds ğ’¯ y âˆ§ x âˆ‰ V âˆ§ y âˆ‰ U

-- a family ğ’¯ is hausdorff (aka T2) if every pair of distinct points have disjoint neighborhoods.
def hausdorff (ğ’¯: Set (Set X)): Prop :=
  âˆ€ x y, x â‰  y â†’ âˆƒ U V, U âˆˆ Nbhds ğ’¯ x âˆ§ V âˆˆ Nbhds ğ’¯ y âˆ§ Disjoint U V

theorem frÃ©chet_implies_hausdorff (ğ’¯: Set (Set X)): hausdorff ğ’¯ â†’ frÃ©chet ğ’¯ := by
  intro h x y h1
  obtain âŸ¨U, V, hU1, hV1, h2âŸ© := h x y h1
  exists U, V
  repeat' (apply And.intro)
  Â· exact hU1
  Â· exact hV1
  Â· exact Disjoint.notMem_of_mem_left h2 (neighborhood_mem hU1)
  Â· exact Disjoint.notMem_of_mem_left (id (Disjoint.symm h2)) (neighborhood_mem hV1)

-- the discrete topology is hausdorff
theorem discrete_hausdorff (X: Type*): hausdorff (@Set.univ (Set X)) := by
  intro x y h
  exists {x}, {y}
  repeat' (apply And.intro)
  Â· exact (discrete_neighborhood_iff {x} x).mpr rfl
  Â· exact (discrete_neighborhood_iff {y} y).mpr rfl
  Â· exact Set.disjoint_singleton.mpr h

-- If X has more than 1 point, the indiscrete topology is nonhausdorff
theorem indiscrete_nonhausdorff {X: Type*} {x y: X} (h: x â‰  y): Â¬ hausdorff {âˆ…, @Set.univ X} := by
  simp [hausdorff]
  exists x, y
  constructor
  Â· exact h
  Â· intro U hU
    simp_all [Nbhds, neighborhood]
    exact Nonempty.intro x

-- the indiscrete space is hausdorff iff. X has one point
theorem indiscrete_nonhausdorff_iff (X: Type*): hausdorff {âˆ…, @Set.univ X} â†” âˆ€ x y: X, x = y := by
  sorry

-- SierpiÅ„ski space is non-hausdorff
theorem sierpiÅ„ski_nonhausdorff: Â¬hausdorff (sierpiÅ„ski_topology.opensets) := by
  apply not_forall.mpr
  exists true
  apply not_forall.mpr
  exists false
  simp
  intro _ ht _ hf
  obtain âŸ¨U, hU1, _, hU3âŸ© := hf
  simp [Disjoint]
  exists {true}
  simp
  repeat' constructor
  Â· exact neighborhood_mem ht
  Â· have: U = {false, true} := by
      rcases hU1 with _ | _ | _
      repeat simp_all
    apply hU3
    simp_all

-- simple lemma: if balls are too far apart, their intersection is empty.
lemma separated_balls [DistanceSpace D] {d: X â†’ X â†’ D} (hd: IsMetric d) {x1 x2: X} {r1 r2: D} (h: r1 + r2 â‰¤ d x1 x2): Disjoint (openball d x1 r1) (openball d x2 r2) := by
  apply Set.disjoint_iff.mpr
  intro x âŸ¨hx1, hx2âŸ©
  apply not_lt_of_ge h
  calc
    d x1 x2 â‰¤ d x1 x + d x x2 := by exact hd.triangle x1 x x2
          _ = d x1 x + d x2 x := by rw [hd.symmetric x x2]
          _ < r1 + r2 := by sorry -- exact? -- add_lt_add hx1 hx2

-- Every metric space is hausdorff.
-- Proof: given two distinct points x, y, let r = d(x, y) / 2. Then B(x, r) and B(y, r) are disjoint neighborhoods.
theorem metric_space_hausdorff {d: X â†’ X â†’ ENNReal} (hd: IsMetric d): hausdorff (metric_opensets d) := by
  intro x y neq
  let r := d x y / 2
  have: d x y â‰  0 := (dist_nonzero_iff hd).mpr neq
  have r_pos: 0 < r := ENNReal.half_pos this
  exists openball d x r, openball d y r
  repeat' (apply And.intro)
  Â· exact openball_neighborhood hd x r_pos
  Â· exact openball_neighborhood hd y r_pos
  Â· simp [separated_balls hd, r]

-- If a space is not hausdorff, it is not metrizable
theorem nonhausdorff_nonmetrizable {ğ’¯: Topology X} (h: Â¬ hausdorff ğ’¯.opensets): Â¬ metrizable ğ’¯ ENNReal := by
  intro âŸ¨d, hdâŸ©
  rw [â†hd] at h
  exact h (metric_space_hausdorff d.is_metric)

-- corollary: sierpiÅ„ski space is nonmetrizable!
theorem sierpiÅ„ski_nonmetrizable: Â¬ metrizable sierpiÅ„ski_topology ENNReal := by
  exact nonhausdorff_nonmetrizable sierpiÅ„ski_nonhausdorff

-- TODO
-- show the cofinite topology is Frechet but not Hausdorff
-- the antidiscrete space is not frechte
-- Let O1, O2 be topologies. If O1 âŠ† O2 then O1 (Hausdorff/Frechet) implies O2 (Hausdorff/Frechet)

theorem frechet_iff (ğ’¯: Set (Set X)): frÃ©chet ğ’¯ â†” âˆ€ x, closedset ğ’¯ {x} := by
  sorry

-- show topology generated by [a, infty) is Frechet but not Hausdorff
-- we can call this the LCRI topology (left closed right infinite) or maybe just OI
def LCRI_base: Set (Set ENNReal) :=
  â‹ƒ (a: ENNReal), {Set.Ici a}

theorem LCRI_base_is_base: is_base LCRI_base := by
  sorry

theorem frechet_iff' (T: Set (Set X)): frÃ©chet T â†” âˆ€ x, {x} = Set.sInter (Nbhds T x) := by
  sorry



-- basis of a subspace

-- properties of topologies of metric spaces

-- product topology

-- equivalence of metrics

theorem hausdorff_iff_diagonal_closed {T: Set (Set X)} (hT: IsTopology T): hausdorff T â†” closedset (product_topology T T) (Set.diagonal X) := by
  sorry

theorem continuous_extension_dense_domain_unique {TX: Set (Set X)} {TY: Set (Set Y)} (A: Set X) (hA: dense TX A) (hY: hausdorff TY) (f1 f2: X â†’ Y) (h: âˆ€ x âˆˆ A, f1 x = f2 x): f1 = f2 := by
  sorry

def regular (T: Set (Set X)): Prop :=
  âˆ€ x, âˆ€ A: Set X, x âˆ‰ A â†’ closedset T A â†’ âˆƒ U V, U âˆˆ T âˆ§ V âˆˆ T âˆ§ x âˆˆ U âˆ§ A âŠ† V âˆ§ U âˆ© V = âˆ…

def T3 (T: Set (Set X)): Prop :=
  hausdorff T âˆ§ regular T

-- def completely_regular (T: Set (Set X)) := sorry
