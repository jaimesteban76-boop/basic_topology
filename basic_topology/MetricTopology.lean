/-

The topology associated to a metric space.

-/

import basic_topology.Metric
import basic_topology.Continuity

variable {X Y D: Type*}

-- definition of an open set in a metric space
-- we will give them the prefix `metric_` since we need these names later
-- note its important that 0 < r in the definition of open set, even though this isnt required to be an open ball.
-- (otherwise every set is trivially open by taking r=0 at every point.)
def metric_open [DistanceSpaceStruct D] (d: X → X → D) (A: Set X): Prop :=
  ∀ x ∈ A, ∃ r, ⊥ < r ∧ openball d x r ⊆ A

def metric_closed [DistanceSpaceStruct D] (d: X → X → D) (A: Set X): Prop :=
  metric_open d Aᶜ

def metric_clopen [DistanceSpaceStruct D] (d: X → X → D) (A: Set X): Prop :=
  metric_open d A ∧ metric_closed d A

-- The empty set is clopen
theorem metric_empty_clopen [DistanceSpace D] [Nontrivial D] (d: X → X → D): metric_clopen d ∅ := by
  constructor
  · intro _ _
    exists ⊥
  · intro _ hx
    obtain ⟨r, hr⟩ := exists_ne (⊥: D)
    exists r
    constructor
    · simp_all
      exact pos_of_ne_zero hr
    · exact fun _ _ => hx

-- If A is clopen then Aᶜ is clopen
theorem clopen_implies_compl_clopen [DistanceSpaceStruct D] (d: X → X → D) {A: Set X} (h: metric_clopen d A): metric_clopen d Aᶜ := by
  constructor
  · exact h.right
  · simp [metric_closed]
    exact h.left

-- A is clopen iff. Aᶜ is clopen
theorem clopen_iff_compl_clopen [DistanceSpaceStruct D] (d: X → X → D) (A: Set X): metric_clopen d A ↔ metric_clopen d Aᶜ := by
  constructor
  · exact clopen_implies_compl_clopen d
  · intro h
    rw [←compl_compl A]
    exact clopen_implies_compl_clopen d h

-- The whole space is clopen
theorem metric_univ_clopen [DistanceSpace D] [Nontrivial D] (d: X → X → D): metric_clopen d Set.univ := by
  rw [←Set.compl_empty]
  exact (clopen_iff_compl_clopen d ∅).mp (metric_empty_clopen d)

-- Open ball is open
-- TODO this needs work since we can't subtract..
theorem openball_open [DistanceSpace D] {d: X → X → D} (hd: IsMetric d) (x: X) (r: D): metric_open d (openball d x r) := by
  intro z hz
  sorry
  -- exists r - d x z
  -- constructor
  -- · exact tsub_pos_of_lt hz
  -- · exact openball_mem_smaller_ball hd

-- Closed ball is closed
theorem closedball_closed [DistanceSpace D] {d: X → X → D} (hd: IsMetric d) (x: X) (r: D): metric_closed d (closedball d x r) := by
  intro x0 hx0
  sorry
  -- exists d x x0 - r
  -- constructor
  -- · simp_all [closedball]
  -- · exact closedball_compl_mem hd hx0

-- the set of open balls in a metric space
def openballs [DistanceSpaceStruct D] (d: X → X → D): Family X :=
  ⋃ (x: X), ⋃ (r: D), {openball d x r}

theorem open_iff_sUnion_of_balls [DistanceSpace D] (d: X → X → D) (hd: IsMetric d) (A: Set X): metric_open d A ↔ ∃ 𝒰 ⊆ openballs d, A = ⋃₀ 𝒰 := by
  apply Iff.intro
  · intro h
    exists fun U => U ⊆ A ∧ U ∈ openballs d
    constructor
    · intro U ⟨_, hU2⟩
      exact hU2
    · ext z
      constructor
      · intro hz
        obtain ⟨r, hr1, hr2⟩ := h z hz
        exists openball d z r
        sorry
        -- repeat' constructor
        -- · exact hr2
        -- · exact z
      · intro ⟨U, ⟨hU1, _⟩, hU3⟩
        exact hU1 hU3
  · intro ⟨𝒰, h𝒰1, h𝒰2⟩
    rw [h𝒰2]
    intro z ⟨U, hU1, hU2⟩
    have := h𝒰1 hU1
    simp_all [openballs]
    obtain ⟨x, r, hx⟩ := this
    sorry
    -- exists r - d x z
    -- constructor
    -- · rw [←hx] at hU2
    --   simp_all [openball]
    -- · calc
    --     openball d z (r - d x z)
    --     _ ⊆ openball d x r := openball_mem_smaller_ball hd
    --     _ = U              := hx
    --     _ ⊆ ⋃₀ 𝒰          := Set.subset_sUnion_of_subset 𝒰 U (fun ⦃a⦄ a ↦ a) hU1

-- the set of all open sets in a metric space
def metric_opens [DistanceSpace D] (d: X → X → D): Family X :=
 {A | metric_open d A}

theorem openballs_sub_opens [DistanceSpace D] {d: X → X → D} (hd: IsMetric d): openballs d ⊆ metric_opens d := by
  intro _ hU
  simp_all [openballs]
  obtain ⟨x, r, hU⟩ := hU
  rw [←hU]
  exact openball_open hd x r

-- Every set is open in the topology generated by the discrete metric.
theorem discrete_opens (X D: Type*) [CompleteDistanceSpace D] [Nontrivial D] [DecidableEq X]: metric_opens (discrete_metric X D) = Set.univ := by
  apply Set.eq_univ_of_univ_subset
  intro A hA x hx
  exists ⊤
  constructor
  · exact bot_lt_top
  · sorry -- simp [discrete_openball_singleton x bot_lt_top]

-- in a metric space, arbitrary unions of open sets are open (doesnt actually depend on d being a metric)
theorem metric_open_sUnion [DistanceSpace D] {d: X → X → D} {C: Family X} (h: C ⊆ metric_opens d): ⋃₀ C ∈ metric_opens d := by
  intro z ⟨U, hU1, hU2⟩
  obtain ⟨r, hr1, hr2⟩ := h hU1 z hU2
  exists r
  constructor
  · exact hr1
  · exact Set.subset_sUnion_of_subset C U hr2 hU1

-- in a metric space, finite intersections of open sets are open
theorem metric_open_finite_sInter [DistanceSpace D] {d: X → X → D} (hd: IsMetric d) {C: Family X} (h1: C ⊆ metric_opens d) (h2: Finite C): ⋂₀ C ∈ metric_opens d := by
  intro z hz
  simp at hz

  -- should be able to get a finite set of radii
  sorry


-- in a metric space every open ball of positive radius is a neighborhood
theorem openball_neighborhood [DistanceSpace D] {d: X → X → D} (hd: IsMetric d) (x: X) {r: D} (hr: ⊥ < r): neighborhood (metric_opens d) (openball d x r) x := by
  exists openball d x r
  repeat' (apply And.intro)
  · apply openballs_sub_opens hd
    simp [openballs]
  · exact (openball_mem_iff hd x r).mpr hr
  · rfl

-- the opens in a metric space form a topology
theorem metric_opens_is_topology [DistanceSpace D] {d: X → X → D} (hd: IsMetric d): IsTopology (metric_opens d) := {
  sUnion := by intro; exact metric_open_sUnion
  finite_sInter := by intro; exact metric_open_finite_sInter hd
}

-- given a metric on X, put a topology on X
def metric_to_topology [DistanceSpace D] (d: Metric X D): Topology X := {
  Open := metric_opens d.distance
  is_topology := metric_opens_is_topology d.is_metric
}

def MetricSpace.opens [DistanceSpace D] (M: MetricSpace D): Set (Set M.points) :=
  metric_opens M.distance

def metrizable (𝒯: Topology X) (D: Type*) [DistanceSpace D]: Prop :=
  ∃ d: Metric X D, metric_to_topology d = 𝒯

-- theorem isometry_homeomorphic_image [DistanceSpace D] {dX: X → X → D} {dY: Y → Y → D} {hX: IsMetric dX} {hY: IsMetric dY} {i: X → Y} (h: isometry dX dY i): homeomorphism (metric_opens dX) (metric_opens (submetric dY (Set.range i))) (Set.rangeFactorization i) := {
--   bijection := by
--     constructor
--     · have := isometry_is_injective hX hY i h
--       simp_all [Set.rangeFactorization, Function.Injective]
--       exact this
--     · exact Set.rangeFactorization_surjective
--   continuous_forward := sorry
--   continuous_inverse := sorry
-- }

theorem continuous_metric_at_iff [DistanceSpace D] (dX: X → X → D) (dY: Y → Y → D) (f: X → Y) (x: X): continuous_metric_at dX dY f x ↔ continuous_at (metric_opens dX) (metric_opens dY) f x := by
  sorry

theorem continuous_metric_iff [DistanceSpace D] (dX: X → X → D) (dY: Y → Y → D) (f: X → Y) (x: X): continuous_metric dX dY f ↔ continuous (metric_opens dX) (metric_opens dY) f := by
  sorry
